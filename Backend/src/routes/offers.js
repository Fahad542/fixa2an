import express from 'express'
import Offer from '../models/Offer.js'
import Request from '../models/Request.js'
import Workshop from '../models/Workshop.js'
import { authenticate, requireRole } from '../middleware/auth.js'

const router = express.Router()

// Create an offer
router.post('/', authenticate, requireRole('WORKSHOP'), async (req, res) => {
	try {
		const { requestId, price, note, availableDates, estimatedDuration, warranty } = req.body

		if (!requestId || !price) {
			return res.status(400).json({ message: 'Request ID and price are required' })
		}

		// Find workshop for this user
		const workshop = await Workshop.findOne({ userId: req.user._id })
		if (!workshop) {
			return res.status(404).json({ message: 'Workshop not found' })
		}

		// Check if request exists and is available
		const request = await Request.findById(requestId)
		if (!request) {
			return res.status(404).json({ message: 'Request not found' })
		}

		if (request.status !== 'NEW' && request.status !== 'IN_BIDDING') {
			return res.status(400).json({ message: 'Request is not available for offers' })
		}

		// Check if offer already exists from this workshop
		const existingOffer = await Offer.findOne({ requestId, workshopId: workshop._id })
		if (existingOffer) {
			return res.status(400).json({ message: 'Offer already exists for this request' })
		}

		const offer = await Offer.create({
			requestId,
			workshopId: workshop._id,
			price: parseFloat(price),
			note,
			availableDates: availableDates ? JSON.stringify(availableDates) : null,
			estimatedDuration,
			warranty,
		})

		// Update request status to IN_BIDDING if it's NEW
		if (request.status === 'NEW') {
			await Request.findByIdAndUpdate(requestId, { status: 'IN_BIDDING' })
		}

		const populatedOffer = await Offer.findById(offer._id)
			.populate('requestId')
			.populate('workshopId')

		return res.status(201).json(populatedOffer)
	} catch (error) {
		console.error('Offer creation error:', error)
		return res.status(500).json({ message: 'Failed to create offer' })
	}
})

// Get offers for a request
router.get('/request/:requestId', authenticate, async (req, res) => {
	try {
		const { requestId } = req.params

		const offers = await Offer.find({ requestId })
			.populate('workshopId', 'companyName rating reviewCount isVerified')
			.sort({ createdAt: -1 })

		return res.json(offers)
	} catch (error) {
		console.error('Fetch offers error:', error)
		return res.status(500).json({ message: 'Failed to fetch offers' })
	}
})

// Update an offer
router.patch('/:id', authenticate, requireRole('WORKSHOP'), async (req, res) => {
	try {
		const { id } = req.params
		const { price, note, availableDates, estimatedDuration, warranty, status } = req.body

		// Find workshop for this user
		const workshop = await Workshop.findOne({ userId: req.user._id })
		if (!workshop) {
			return res.status(404).json({ message: 'Workshop not found' })
		}

		// Build update object
		const updateData = {}
		if (price !== undefined) updateData.price = parseFloat(price)
		if (note !== undefined) updateData.note = note
		if (availableDates !== undefined) updateData.availableDates = availableDates ? JSON.stringify(availableDates) : null
		if (estimatedDuration !== undefined) updateData.estimatedDuration = estimatedDuration
		if (warranty !== undefined) updateData.warranty = warranty
		// Allow status update for cancelling contracts
		if (status !== undefined) updateData.status = status

		// Find and update the offer (only if it belongs to this workshop)
		const offer = await Offer.findOneAndUpdate(
			{ _id: id, workshopId: workshop._id },
			updateData,
			{ new: true }
		)

		if (!offer) {
			return res.status(404).json({ message: 'Offer not found or you do not have permission to update it' })
		}

		const populatedOffer = await Offer.findById(offer._id)
			.populate('requestId')
			.populate('workshopId')

		return res.json(populatedOffer)
	} catch (error) {
		console.error('Offer update error:', error)
		return res.status(500).json({ message: 'Failed to update offer' })
	}
})

// Get offers by workshop
router.get('/workshop/me', authenticate, requireRole('WORKSHOP'), async (req, res) => {
	try {
		// Find workshop for this user
		const workshop = await Workshop.findOne({ userId: req.user._id })
		if (!workshop) {
			return res.status(404).json({ message: 'Workshop not found' })
		}

		const offers = await Offer.find({ workshopId: workshop._id })
			.populate({
				path: 'requestId',
				select: 'description status createdAt',
				populate: [
					{ 
						path: 'vehicleId', 
						select: 'make model year' 
					},
					{ 
						path: 'customerId', 
						select: 'name email phone' 
					}
				]
			})
			.sort({ createdAt: -1 })

		return res.json(offers)
	} catch (error) {
		console.error('Fetch workshop offers error:', error)
		return res.status(500).json({ message: 'Failed to fetch offers' })
	}
})

// Get available requests for workshops
router.get('/requests/available', authenticate, requireRole('WORKSHOP'), async (req, res) => {
	try {
		const { latitude, longitude, radius = 30 } = req.query

		// Find workshop for this user
		const workshop = await Workshop.findOne({ userId: req.user._id })
		if (!workshop) {
			return res.status(404).json({ message: 'Workshop not found' })
		}

		const searchLat = parseFloat(latitude) || workshop.latitude
		const searchLng = parseFloat(longitude) || workshop.longitude
		const searchRadius = parseFloat(radius)

		// Find requests within radius
		const requests = await Request.find({
			status: { $in: ['NEW', 'IN_BIDDING'] },
			expiresAt: { $gt: new Date() },
		})
			.populate('vehicleId')
			.populate('reportId')
			.populate('customerId', 'name email')
			.sort({ createdAt: -1 })

		// Filter by distance and exclude requests that already have offers from this workshop
		const requestIds = requests.map((r) => r._id)
		const existingOffers = await Offer.find({
			workshopId: workshop._id,
			requestId: { $in: requestIds },
		})

		const existingRequestIds = new Set(existingOffers.map((o) => o.requestId.toString()))

		const filteredRequests = requests
			.filter((req) => {
				const distance = calculateDistance(
					searchLat,
					searchLng,
					req.latitude,
					req.longitude
				)
				return distance <= searchRadius && !existingRequestIds.has(req._id.toString())
			})
			.map((req) => ({
				...req.toObject(),
				distance: calculateDistance(searchLat, searchLng, req.latitude, req.longitude),
			}))

		return res.json(filteredRequests)
	} catch (error) {
		console.error('Fetch available requests error:', error)
		return res.status(500).json({ message: 'Failed to fetch available requests' })
	}
})

// Helper function to calculate distance
function calculateDistance(lat1, lon1, lat2, lon2) {
	const R = 6371
	const dLat = ((lat2 - lat1) * Math.PI) / 180
	const dLon = ((lon2 - lon1) * Math.PI) / 180
	const a =
		Math.sin(dLat / 2) * Math.sin(dLat / 2) +
		Math.cos((lat1 * Math.PI) / 180) *
			Math.cos((lat2 * Math.PI) / 180) *
			Math.sin(dLon / 2) *
			Math.sin(dLon / 2)
	const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
	return R * c
}

export default router

